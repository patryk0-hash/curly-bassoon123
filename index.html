<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Shooter — Rounds</title>
<style>
  html,body { height:100%; margin:0; background:#111; color:#ddd; font-family:Inter, Arial, sans-serif; }
  #ui { position:fixed; left:8px; top:8px; z-index:10; }
  #info { background: rgba(0,0,0,0.5); padding:10px; border-radius:8px; }
  canvas { display:block; margin:auto; background: linear-gradient(#6dd5ed,#2193b0); box-shadow:0 6px 20px rgba(0,0,0,0.6); border-radius:6px; margin-top:40px; }
  .hint { font-size:13px; color:#ccc; margin-top:6px; }
  #overlay { position:fixed; left:0;right:0;top:0;bottom:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .panel { background:rgba(0,0,0,0.7); color:#fff; padding:20px 28px; border-radius:8px; text-align:center; pointer-events:auto; }
  button { background:#0b84ff; color:white; border:none; padding:10px 14px; border-radius:6px; cursor:pointer; font-weight:700; }
  button:active{ transform:translateY(1px); }
</style>
</head>
<body>
<div id="ui">
  <div id="info">
    <div><strong id="matchLabel">Match: 0 - 0</strong> &nbsp; | &nbsp; Round <span id="roundNum">0</span>/5</div>
    <div>Round timer: <span id="timer">0:00</span></div>
    <div>Round winner: <span id="roundWinner">—</span></div>
    <div class="hint">Controls: W A S D to move • Aim with mouse • Click or SPACE to shoot</div>
  </div>
</div>

<canvas id="gameCanvas" width="900" height="600"></canvas>

<div id="overlay"></div>

<script>
/* ============================
   PIXEL SHOOTER — single-file
   - Top-down pixel shooter
   - AI bots, teams, rounds, 3-min rounds
   - Drop into GitHub Pages as shooter.html
   ============================ */

/* CONFIG */
const CONFIG = {
  canvasWidth: 900, canvasHeight: 600,
  roundDurationSec: 180, // 3 minutes
  roundsPerMatch: 5,
  startingPlayersPerTeam: 3, // includes player on blue
  botAccuracy: 0.7, // 0..1 (higher = more accurate)
  bulletSpeed: 9,
  bulletDamage: 25,
  playerMaxHP: 100,
  botMaxHP: 80,
  fireCooldown: 300, // ms
  botFireCooldown: 600,
  respawnBetweenRoundsMs: 1500
};

/* DOM elements */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.canvasWidth; canvas.height = CONFIG.canvasHeight;
const timerEl = document.getElementById('timer');
const roundNumEl = document.getElementById('roundNum');
const matchLabelEl = document.getElementById('matchLabel');
const roundWinnerEl = document.getElementById('roundWinner');
const overlay = document.getElementById('overlay');

/* GAME STATE */
let matchScore = { blue: 0, red: 0 };
let currentRound = 0;
let roundTimeLeft = CONFIG.roundDurationSec;
let roundActive = false;
let roundWinner = null;
let players = []; // all players (player + bots)
let bullets = [];
let lastTick = 0;
let mouse = { x: canvas.width/2, y: canvas.height/2, down: false };
let keys = {};
let gamePaused = false;

/* UTILS */
function rand(min, max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(a,b){ let dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
function now(){ return performance.now(); }

/* ENTITY CREATION */
function createPlayer(x,y,team,isHuman=false,id=null){
  return {
    id: id || Math.random().toString(36).slice(2,9),
    x, y, w:18, h:18,
    vx:0, vy:0, speed: 2.4,
    team, hp: team==='blue'?CONFIG.playerMaxHP:CONFIG.botMaxHP,
    alive: true, human:isHuman,
    lastFire: 0,
    name: isHuman ? 'YOU' : (team==='blue' ? 'BlueBot' : 'RedBot')
  };
}

/* SETUP TEAMS */
function startMatch(){
  matchScore = {blue:0, red:0};
  currentRound = 0;
  nextRound();
}

function nextRound(){
  if(matchScore.blue >= Math.ceil(CONFIG.roundsPerMatch/2) || matchScore.red >= Math.ceil(CONFIG.roundsPerMatch/2)){
    showMatchOver();
    return;
  }
  currentRound++;
  roundNumEl.innerText = currentRound;
  roundWinner = null;
  roundWinnerEl.innerText = '—';
  roundTimeLeft = CONFIG.roundDurationSec;
  bullets = [];
  players = [];

  // Spawn players: blue team includes human player at left, bots; red team bots on right
  const spawnLeftX = 100, spawnRightX = canvas.width - 100;
  const spacing = 60;
  // blue team: human + (n-1) bots
  createAndAddPlayer(spawnLeftX, canvas.height/2, 'blue', true);
  for(let i=1;i<CONFIG.startingPlayersPerTeam;i++){
    createAndAddPlayer(spawnLeftX, canvas.height/2 + (i*spacing) - spacing*1.2, 'blue', false);
  }
  // red bots
  for(let i=0;i<CONFIG.startingPlayersPerTeam;i++){
    createAndAddPlayer(spawnRightX, canvas.height/2 + (i*spacing) - spacing*1.2, 'red', false);
  }

  roundActive = true;
  runRoundTimer();
  showOverlayMessage(`Round ${currentRound} — GO!`, 900);
  lastTick = now();
  loop();
}

function createAndAddPlayer(x,y,team,isHuman){
  const p = createPlayer(x+rand(-30,30), y+rand(-30,30), team, isHuman);
  players.push(p);
  return p;
}

/* ROUND TIMER */
let roundTimerInterval = null;
function runRoundTimer(){
  if(roundTimerInterval) clearInterval(roundTimerInterval);
  roundTimerInterval = setInterval(()=>{
    if(!roundActive) return;
    roundTimeLeft -= 1;
    updateTimerDisplay();
    if(roundTimeLeft <= 0){
      // time up: evaluate surviving team with more alive players
      endRoundByTimer();
    }
  }, 1000);
}
function updateTimerDisplay(){
  const m = Math.floor(roundTimeLeft/60);
  const s = roundTimeLeft%60;
  timerEl.innerText = `${m}:${s.toString().padStart(2,'0')}`;
}

/* INPUTS */
canvas.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
});
window.addEventListener('mousedown', e=>{ mouse.down = true; });
window.addEventListener('mouseup', e=>{ mouse.down = false; });
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key===' '){ mouse.down = true; } });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; if(e.key===' '){ mouse.down = false; } });

/* SHOOT */
function tryFire(shooter){
  const nowMs = now();
  const cooldown = shooter.human ? CONFIG.fireCooldown : CONFIG.botFireCooldown;
  if(nowMs - shooter.lastFire < cooldown) return;
  shooter.lastFire = nowMs;

  // direction
  let targetX = mouse.x, targetY = mouse.y;
  if(!shooter.human){
    // pick target nearest enemy
    const enemies = players.filter(p=>p.team !== shooter.team && p.alive);
    if(enemies.length===0) return;
    const t = enemies.reduce((a,b)=> dist(shooter,b) < dist(shooter,a) ? b : a);
    targetX = t.x + t.w/2; targetY = t.y + t.h/2;
    // add bot inaccuracy
    const inacc = (1 - CONFIG.botAccuracy) * 60;
    targetX += rand(-inacc,inacc); targetY += rand(-inacc,inacc);
  }

  const dx = targetX - (shooter.x + shooter.w/2);
  const dy = targetY - (shooter.y + shooter.h/2);
  const mag = Math.sqrt(dx*dx+dy*dy);
  if(mag === 0) return;
  const vx = dx / mag * CONFIG.bulletSpeed;
  const vy = dy / mag * CONFIG.bulletSpeed;

  bullets.push({
    x: shooter.x + shooter.w/2,
    y: shooter.y + shooter.h/2,
    vx, vy,
    ownerId: shooter.id,
    team: shooter.team,
    life: 3000, // ms
    created: now()
  });
}

/* AI BEHAVIOR */
function botThink(bot){
  if(!bot.alive) return;
  // find nearest enemy
  const enemies = players.filter(p=>p.team !== bot.team && p.alive);
  if(enemies.length===0) return;

  const target = enemies.reduce((a,b)=> dist(bot,b) < dist(bot,a) ? b : a);
  // move toward target, with slight strafing behavior
  const dx = target.x - bot.x;
  const dy = target.y - bot.y;
  const d = Math.sqrt(dx*dx+dy*dy);
  if(d > 35){
    bot.vx = (dx/d) * bot.speed;
    bot.vy = (dy/d) * bot.speed;
  } else { bot.vx = 0; bot.vy = 0; }

  // occasionally dodge: small random strafe
  if(Math.random() < 0.01){
    bot.vx += rand(-0.6,0.6);
    bot.vy += rand(-0.6,0.6);
  }

  // shoot if roughly facing target and in range
  if(d < 420 && Math.random() < 0.5) tryFire(bot);
}

/* PHYSICS AND COLLISIONS */
function update(dt){
  // update players movement
  players.forEach(p=>{
    if(!p.alive) return;
    if(p.human){
      // input movement WASD
      let mx=0,my=0;
      if(keys['w']) my -= 1;
      if(keys['s']) my += 1;
      if(keys['a']) mx -= 1;
      if(keys['d']) mx += 1;
      if(mx !== 0 || my !== 0){
        const md = Math.sqrt(mx*mx + my*my);
        p.vx = (mx/md) * p.speed;
        p.vy = (my/md) * p.speed;
      } else { p.vx = 0; p.vy = 0; }
      // shoot with mouse
      if(mouse.down) tryFire(p);
    } else {
      botThink(p);
    }
    // apply velocity
    p.x += p.vx;
    p.y += p.vy;
    // clamp to arena
    p.x = clamp(p.x, 10, canvas.width-10-p.w);
    p.y = clamp(p.y, 10, canvas.height-10-p.h);
  });

  // update bullets
  const nowMs = now();
  for(let i = bullets.length-1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    if(nowMs - b.created > b.life) { bullets.splice(i,1); continue; }
    // out of bounds
    if(b.x < -20 || b.x > canvas.width+20 || b.y < -20 || b.y > canvas.height+20){
      bullets.splice(i,1); continue;
    }
    // collision with players
    for(let j=0;j<players.length;j++){
      const p = players[j];
      if(!p.alive) continue;
      if(p.id === b.ownerId) continue; // no self-damage
      // team check
      if(p.team === b.team) continue;
      // bounding box check
      if(b.x > p.x && b.x < p.x + p.w && b.y > p.y && b.y < p.y + p.h){
        // hit
        p.hp -= CONFIG.bulletDamage;
        bullets.splice(i,1);
        if(p.hp <= 0){
          p.alive = false;
        }
        break;
      }
    }
  }

  /* end-round check: if one team has zero alive players -> round ends */
  const blueAlive = players.filter(p=>p.team==='blue' && p.alive).length;
  const redAlive  = players.filter(p=>p.team==='red' && p.alive).length;
  if(roundActive && (blueAlive === 0 || redAlive === 0)){
    const winnerTeam = blueAlive === 0 ? 'red' : 'blue';
    finishRound(winnerTeam);
  }
}

/* ROUND END / WIN LOGIC */
function endRoundByTimer(){
  if(!roundActive) return;
  // choose team with more alive players; tie => no winner
  const blueAlive = players.filter(p=>p.team==='blue' && p.alive).length;
  const redAlive  = players.filter(p=>p.team==='red' && p.alive).length;
  if(blueAlive > redAlive) finishRound('blue');
  else if(redAlive > blueAlive) finishRound('red');
  else finishRound(null); // tie
}

function finishRound(winner){
  roundActive = false;
  roundWinner = winner;
  roundWinnerEl.innerText = winner ? winner.toUpperCase() : 'TIE';
  if(winner) matchScore[winner]++;
  matchLabelEl.innerText = `Match: ${matchScore.blue} - ${matchScore.red}`;
  // show message
  if(winner) showOverlayMessage(`${winner.toUpperCase()} wins round ${currentRound}`, 1600);
  else showOverlayMessage(`Round ${currentRound} ended in a tie`, 1600);

  // short delay, then next round or match end
  setTimeout(()=>{
    if(matchScore.blue >= Math.ceil(CONFIG.roundsPerMatch/2) || matchScore.red >= Math.ceil(CONFIG.roundsPerMatch/2) || currentRound >= CONFIG.roundsPerMatch){
      showMatchOver();
    } else {
      // respawn and start next round
      setTimeout(()=> nextRound(), CONFIG.respawnBetweenRoundsMs);
    }
  }, 900);
}

function showMatchOver(){
  roundActive = false;
  clearInterval(roundTimerInterval);
  let winnerText = matchScore.blue > matchScore.red ? 'BLUE WINS MATCH' : (matchScore.red > matchScore.blue ? 'RED WINS MATCH' : 'MATCH TIED');
  showOverlayMessage(`${winnerText}<br><br>Refresh to play again`, 99999999, true);
}

/* DRAWING */
function draw(){
  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // field grid for pixel vibe
  for(let y=0;y<canvas.height;y+=20){
    ctx.fillStyle = (y%40===0) ? 'rgba(255,255,255,0.02)' : 'rgba(0,0,0,0.01)';
    ctx.fillRect(0,y,canvas.width,20);
  }

  // draw bullets
  bullets.forEach(b=>{
    ctx.fillStyle = b.team==='blue' ? '#66ccff' : '#ff6666';
    ctx.fillRect(b.x-3, b.y-3, 6,6);
  });

  // draw players
  players.forEach(p=>{
    if(!p.alive){
      // draw a faint skull or X
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      return;
    }
    // body
    ctx.fillStyle = p.team === 'blue' ? '#2a9df4' : '#e24b4b';
    // add a little border to look pixel-like
    ctx.fillRect(p.x-1, p.y-1, p.w+2, p.h+2);
    ctx.fillStyle = p.team === 'blue' ? '#1a7fcf' : '#b83b3b';
    ctx.fillRect(p.x, p.y, p.w, p.h);

    // face (tiny)
    ctx.fillStyle = '#111';
    ctx.fillRect(p.x+4, p.y+5, 3,3);

    // health bar
    const hpPct = clamp(p.hp / (p.human ? CONFIG.playerMaxHP : CONFIG.botMaxHP), 0, 1);
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(p.x, p.y - 8, p.w, 6);
    ctx.fillStyle = hpPct > 0.5 ? '#7bed9f' : (hpPct > 0.2 ? '#f1c40f' : '#ff6b6b');
    ctx.fillRect(p.x, p.y - 8, p.w * hpPct, 6);

    // name
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '11px Arial';
    ctx.fillText(p.human? 'YOU' : p.name, p.x - 4, p.y - 12);
  });

  // HUD - score displayed better
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(canvas.width - 200, 8, 190, 52);
  ctx.fillStyle = '#66ccff';
  ctx.font = '18px Arial';
  ctx.fillText(`BLUE ${matchScore.blue}`, canvas.width - 190, 28);
  ctx.fillStyle = '#ff9999';
  ctx.fillText(`RED ${matchScore.red}`, canvas.width - 190, 48);
}

/* LOOP */
function loop(){
  if(!roundActive) return;
  const t = now();
  const dt = t - lastTick;
  lastTick = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* Overlays and messages */
function showOverlayMessage(html, timeout=1200, persistent=false){
  overlay.innerHTML = '';
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.innerHTML = `<div style="font-size:20px;font-weight:800;margin-bottom:6px">${html}</div>`;
  if(!persistent){
    overlay.appendChild(panel);
    setTimeout(()=>{ overlay.innerHTML = ''; }, timeout);
  } else {
    panel.innerHTML += `<div style="margin-top:12px"><button onclick="location.reload()">Play again</button></div>`;
    overlay.appendChild(panel);
  }
}

/* START */
updateTimerDisplay();
startMatch();

</script>
</body>
</html>
